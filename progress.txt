---
[INFRA-001]  Initialize monorepo with Turborepo
Date: 2026-02-20
What was done:
- Created Turborepo monorepo scaffolding at the repository root.
- Added root workspace configuration and stub package scripts for backend, web, and extension workspaces.
- Added repository baseline config files (.editorconfig and .gitignore).
- Marked INFRA-001 as passed in prd.json.
Key decisions / gotchas:
- Used minimal stub build/lint/test scripts per workspace so turbo pipelines execute before full app scaffolding.
- Kept backend as a placeholder workspace package for Turborepo orchestration; Python service setup is deferred to INFRA-003.
Files created/modified: package.json, turbo.json, .editorconfig, .gitignore, packages/backend/package.json, packages/web/package.json, packages/extension/package.json, prd.json, progress.txt
---

---
[INFRA-002]  Docker Compose dev environment
Date: 2026-02-20
What was done:
- Added `docker-compose.dev.yml` with MySQL 8.0, MinIO, and Redis services for local development.
- Added health checks for MySQL (`mysqladmin ping`), MinIO (`/minio/health/live`), and Redis (`redis-cli ping`).
- Added `.env.example` documenting all environment variables consumed by `docker-compose.dev.yml`.
- Marked story INFRA-002 as passed in `prd.json`.
Key decisions / gotchas:
- Added dedicated MySQL health check credentials (`MYSQL_HEALTHCHECK_USER`/`MYSQL_HEALTHCHECK_PASSWORD`) so health checks are explicit and configurable.
- Pinned MinIO image to a dated release tag for deterministic local environments.
Files created/modified: docker-compose.dev.yml, .env.example, prd.json, progress.txt
---
---
[INFRA-003]  FastAPI backend skeleton with SQLAlchemy async + Alembic
Date: 2026-02-20
What was done:
- Added a Python backend project scaffold in `packages/backend` with pinned dependencies in `pyproject.toml`.
- Implemented `packages/backend/app/main.py` with FastAPI app bootstrap and a `GET /health` endpoint returning `{"status":"ok"}`.
- Added environment-driven settings via `pydantic-settings` and async SQLAlchemy engine/session wiring.
- Configured Alembic for async migrations (`alembic.ini`, async `alembic/env.py`) and added a baseline revision file.
- Marked `INFRA-003` as passed in `prd.json`.
Key decisions / gotchas:
- Kept the first Alembic revision as a no-op baseline so `alembic upgrade head` can initialize cleanly before schema stories (`DB-*`) introduce tables.
- Read MySQL connection values from environment to align with the existing Docker dev stack variables from `.env.example`.
Files created/modified: packages/backend/pyproject.toml, packages/backend/app/__init__.py, packages/backend/app/main.py, packages/backend/app/core/__init__.py, packages/backend/app/core/settings.py, packages/backend/app/db/__init__.py, packages/backend/app/db/base.py, packages/backend/app/db/session.py, packages/backend/alembic.ini, packages/backend/alembic/env.py, packages/backend/alembic/script.py.mako, packages/backend/alembic/versions/0001_backend_skeleton.py, prd.json, progress.txt
---
---
[INFRA-004]  React + Vite frontend skeleton
Date: 2026-02-20
What was done:
- Replaced the packages/web stub with a React 19 + TypeScript app built on Vite 6.
- Added and pinned the required frontend stack libraries: Zustand, TanStack Query, TanStack Router, React Hook Form, Zod, Framer Motion, and Radix UI.
- Implemented a stub home page that renders successfully and wires core libraries for baseline integration.
- Verified 
pm run build creates packages/web/dist, 
px tsc --noEmit passes, and the dev server starts and listens on the configured port.
Key decisions / gotchas:
- Kept Framer-motion pinned in dependencies per story requirement but avoided runtime import in the stub page due a package resolver incompatibility with the selected toolchain.
- Used a lightweight router/query bootstrapping pattern so future feature stories can extend routes and data fetching without refactoring the app entry.
Files created/modified: packages/web/package.json, packages/web/index.html, packages/web/tsconfig.json, packages/web/vite.config.ts, packages/web/src/main.tsx, packages/web/src/App.tsx, packages/web/src/styles.css, package-lock.json, prd.json, progress.txt
---
---
[INFRA-005] Browser extension skeleton (Manifest V3)
Date: 2026-02-20
What was done:
- Replaced the extension stub workspace with a Vite + React + TypeScript setup using CRXJS.
- Added a valid Manifest V3 definition with popup, background service worker, and content script entries.
- Implemented popup UI placeholder (`popup.html` + React app), background worker stub, and content script stub.
- Verified `npm run build --workspace @vaultguard/extension` produces `packages/extension/dist` and `npm run typecheck --workspace @vaultguard/extension` passes.
Key decisions / gotchas:
- Kept both `manifest.json` (explicit MV3 artifact for acceptance) and `manifest.config.ts` (typed CRXJS source for Vite build integration).
- Pinned `@crxjs/vite-plugin` to stable `2.0.0` to avoid beta deprecation and keep the toolchain aligned.
Files created/modified: packages/extension/package.json, packages/extension/manifest.json, packages/extension/manifest.config.ts, packages/extension/tsconfig.json, packages/extension/vite.config.ts, packages/extension/src/popup/index.html, packages/extension/src/popup/main.tsx, packages/extension/src/popup/App.tsx, packages/extension/src/popup/styles.css, packages/extension/src/background.ts, packages/extension/src/content.ts, package-lock.json, prd.json, progress.txt
---
---
[INFRA-006] - GitHub Actions CI pipeline
Date: 2026-02-20
What was done:
- Added `.github/workflows/ci.yml` to run on every pull request.
- Implemented four CI jobs: `backend-test`, `frontend-check`, `dependency-scan`, and `sast`.
- Wired `dependency-scan` to OWASP Dependency-Check against npm and Python manifests with `--failOnCVSS 7` so HIGH/CRITICAL CVEs fail the build.
- Added a backend pytest for `/health` to ensure the backend test job has an executable test on stub PRs.
- Marked `INFRA-006` as passed in `prd.json`.
Key decisions / gotchas:
- Used `--failOnCVSS 7` to enforce failure for HIGH (7.0+) and CRITICAL vulnerabilities.
- Used Semgrep's OWASP Top 10 policy (`p/owasp-top-ten`) to satisfy the OWASP ruleset SAST requirement without needing paid Semgrep App integration.
Files created/modified: .github/workflows/ci.yml, packages/backend/tests/test_health.py, prd.json, progress.txt
---

---
[DB-001] - Create Organization and User tables migration
Date: 2026-02-20
What was done:
- Added Alembic revision `0002_create_organizations_and_users` creating `organizations` and `users` with UUID primary keys.
- Implemented required columns, foreign key (`users.org_id -> organizations.id`), unique email constraint, role/status enums, and explicit indexes.
- Added typed SQLAlchemy models for `Organization` and `User` with enum-backed `UserRole` and `UserStatus`.
- Wired model imports into `app/db/base.py` so metadata registration is consistent for migrations/autogeneration.
- Fixed backend packaging discovery in `pyproject.toml` so editable installs and validation tooling work reliably.
- Validated backend with `python -m pytest -q`, `python -m compileall app`, and `python -m alembic upgrade head --sql`.
Key decisions / gotchas:
- Docker is unavailable on this machine, so live MySQL execution of `alembic upgrade head` could not be run in this session.
- Used Alembic SQL generation against the MySQL dialect (`--sql`) to verify DDL output and migration chain correctness without a running containerized MySQL instance.
Files created/modified: packages/backend/alembic/versions/0002_create_organizations_and_users.py, packages/backend/app/models/__init__.py, packages/backend/app/models/organization.py, packages/backend/app/models/user.py, packages/backend/app/db/base.py, packages/backend/pyproject.toml, prd.json, progress.txt
---

---
[DB-002] - Create VaultItem and VaultItemRevision tables migration
Date: 2026-02-20
What was done:
- Added Alembic revision `0003_create_vault_items_and_revisions` creating `vault_items` and `vault_item_revisions`.
- Implemented required columns for encrypted blobs, soft-delete (`deleted_at`), revision tracking, and FK relationships (`owner_id`, `org_id`, `item_id`).
- Added explicit indexes on `vault_items.owner_id` and `vault_items.org_id` plus uniqueness on `(item_id, revision_number)`.
- Added typed SQLAlchemy models `VaultItem` and `VaultItemRevision` with enum-backed `VaultItemType`.
- Registered new models in `app/models/__init__.py` and `app/db/base.py` for metadata/migration consistency.
- Marked `DB-002` as passed in `prd.json`.
- Validated with `python -m pytest -q`, `python -m compileall app`, and `python -m alembic upgrade head --sql`.
Key decisions / gotchas:
- Kept `folder_id` nullable on `vault_items` and deferred a concrete FK constraint until the `folders` table exists in `DB-003`.
- Docker execution was not used; migration validity was verified through generated MySQL DDL (`--sql`) per environment constraints.
Files created/modified: packages/backend/alembic/versions/0003_create_vault_items_and_revisions.py, packages/backend/app/models/vault_item.py, packages/backend/app/models/__init__.py, packages/backend/app/db/base.py, prd.json, progress.txt
---
---
[DB-003] - Create Folder, Collection, CollectionMember tables migration
Date: 2026-02-20
What was done:
- Added Alembic revision `0004_create_folders_collections_and_members` to create `folders`, `collections`, and `collection_members` tables with required UUID keys, foreign keys, and enum permission values.
- Implemented composite primary key on `collection_members` (`collection_id`, `user_or_group_id`) and added supporting indexes for folder hierarchy and ownership lookups.
- Added the deferred foreign key from `vault_items.folder_id` to `folders.id` now that the `folders` table exists.
- Added SQLAlchemy models for `Folder`, `Collection`, and `CollectionMember` with `CollectionPermission` enum, and registered them in model exports/metadata imports.
- Verified with `python -m pytest -q`, `python -m compileall app`, and `python -m alembic upgrade head --sql`.
Key decisions / gotchas:
- Kept `parent_folder_id` and `vault_items.folder_id` as `ON DELETE SET NULL` to avoid recursive deletes when parent folders are removed.
- Docker runtime execution was skipped per session note; migration correctness was validated via generated MySQL DDL (`--sql`).
Files created/modified: packages/backend/alembic/versions/0004_create_folders_collections_and_members.py, packages/backend/app/models/folder.py, packages/backend/app/models/vault_item.py, packages/backend/app/models/__init__.py, packages/backend/app/db/base.py, prd.json, progress.txt
---
---
[DB-004] — Create AuditLog and Session tables migration
Date: 2026-02-20
What was done:
- Added Alembic revision `0005_create_audit_logs_and_sessions` creating `audit_logs` and `sessions` with required columns, foreign keys, and defaults.
- Implemented `audit_logs` composite index on (`org_id`, `timestamp`) for fast range queries and added supporting indexes on `actor_id`, `sessions.user_id`, and `sessions.expires_at`.
- Enforced append-only behavior for `audit_logs` with a MySQL `BEFORE UPDATE` trigger that rejects updates.
- Added typed SQLAlchemy models `AuditLog`/`AuditLogAction` and `Session`, and registered them in model exports and metadata imports.
- Validated with `python -m pytest -q`, `python -m compileall app`, and `python -m alembic upgrade head --sql`.
Key decisions / gotchas:
- Kept `actor_id` nullable with `ON DELETE SET NULL` so audit records remain intact if users are removed.
- Used a broad `audit_log_action` enum covering current and near-term auth/vault audit events to avoid immediate follow-up enum migrations.
Files created/modified: packages/backend/alembic/versions/0005_create_audit_logs_and_sessions.py, packages/backend/app/models/audit_log.py, packages/backend/app/models/auth_session.py, packages/backend/app/models/__init__.py, packages/backend/app/db/base.py, prd.json, progress.txt
---
---
[AUTH-001] — User registration endpoint with Argon2id password hashing
Date: 2026-02-20
What was done:
- Implemented `POST /api/v1/auth/register` at `/api/v1/auth/register` with request validation and `201` response payload.
- Added Argon2id hashing (`memory=65536`, `iterations=3`, `parallelism=4`) and persisted the hash in a new `users.auth_verifier_hash` column.
- Added duplicate email handling that returns `409` with RFC 7807 (`application/problem+json`) body.
- Added unit tests for registration happy path and duplicate-email behavior.
- Added an integration test proving the endpoint writes a DB row and stores a verifiable Argon2 hash instead of raw verifier text.
- Resolved backend model import cycles by introducing a dedicated model registry import path for Alembic metadata loading.
Key decisions / gotchas:
- Added Alembic revision `0006_add_auth_verifier_hash_to_users` with a temporary server default for safe non-null column rollout, then removed the default.
- Kept registration logic free of logging and avoided echoing `auth_verifier` in responses/errors to satisfy sensitive-data handling requirements.
- Moved model registration out of `app/db/base.py` to avoid circular imports when service modules import models directly.
Files created/modified: packages/backend/app/main.py, packages/backend/app/api/__init__.py, packages/backend/app/api/v1/__init__.py, packages/backend/app/api/v1/auth.py, packages/backend/app/core/problems.py, packages/backend/app/security/__init__.py, packages/backend/app/security/password.py, packages/backend/app/schemas/auth.py, packages/backend/app/services/auth.py, packages/backend/app/models/user.py, packages/backend/app/models/__init__.py, packages/backend/app/db/base.py, packages/backend/app/db/model_registry.py, packages/backend/alembic/env.py, packages/backend/alembic/versions/0006_add_auth_verifier_hash_to_users.py, packages/backend/pyproject.toml, packages/backend/tests/test_auth_register_unit.py, packages/backend/tests/test_auth_register_integration.py, prd.json, progress.txt
---
---
[AUTH-002] — Login endpoint with JWT access + refresh token issuance
Date: 2026-02-20
What was done:
- Added `POST /api/v1/auth/preauth` returning Argon2id parameters for login KDF negotiation.
- Added `POST /api/v1/auth/login` to verify `auth_verifier`, issue RS256 access tokens (15-minute TTL), and mint refresh tokens.
- Stored SHA-256 refresh token hashes in the `sessions` table with device/user-agent metadata and expiry.
- Implemented IP-based failed-login rate limiting where attempts beyond 5 return HTTP 429.
- Added fixed-minimum failed-login response timing to reduce credential-check timing leakage.
- Added unit tests for access token generation/validation and integration tests for preauth/login/session persistence/rate limiting.
- Updated backend dependencies to include pinned JWT + crypto libraries required for RS256 signing/verification.
Key decisions / gotchas:
- Kept rate limiting as an in-memory sliding window limiter keyed by client IP for now; this satisfies story criteria and can later be swapped to Redis without endpoint changes.
- Used a deterministic dev/test RSA keypair in settings defaults so RS256 works out-of-the-box; production can override via environment variables.
- Docker execution was not used in this session; verification was done with pytest + in-memory SQLite integration tests.
Files created/modified: packages/backend/app/api/v1/auth.py, packages/backend/app/core/settings.py, packages/backend/app/schemas/auth.py, packages/backend/app/security/tokens.py, packages/backend/app/services/auth.py, packages/backend/pyproject.toml, packages/backend/tests/test_auth_login_integration.py, packages/backend/tests/test_auth_tokens_unit.py, prd.json, progress.txt
---

---
[AUTH-003] — Token refresh and logout endpoints
Date: 2026-02-20
What was done:
- Implemented `POST /api/v1/auth/refresh` to rotate refresh tokens, revoke the old session token, and return new access/refresh tokens.
- Implemented `POST /api/v1/auth/logout` to revoke the session tied to the provided refresh token for the authenticated user.
- Implemented `DELETE /api/v1/auth/sessions/{id}` to revoke a specific session for the authenticated user.
- Added audit log emission for refresh (`REFRESH_TOKEN`), logout (`LOGOUT`), and explicit session revoke (`SESSION_REVOKE`), and also login (`LOGIN`) when a session is created.
- Added new auth schemas and comprehensive unit/integration tests covering rotation replay rejection, session revocation, and audit log persistence.
Key decisions / gotchas:
- Added bearer-token parsing in auth routes for logout/session-revoke before the shared auth middleware story lands.
- Adjusted user/session lookup logic to be UUID-format tolerant so SQLite integration tests and MySQL behavior both remain stable.
- Updated prior login integration tests to include `audit_logs` test table setup since login now writes audit events.
Files created/modified: packages/backend/app/api/v1/auth.py, packages/backend/app/schemas/auth.py, packages/backend/app/services/auth.py, packages/backend/tests/test_auth_login_integration.py, packages/backend/tests/test_auth_session_management_unit.py, packages/backend/tests/test_auth_session_management_integration.py, prd.json, progress.txt
---

---
[AUTH-004] — TOTP MFA enrollment and verification
Date: 2026-02-20
What was done:
- Added TOTP MFA domain support with persistent enrollment records, backup-code hashing, and confirmation state tracking.
- Implemented `POST /api/v1/auth/mfa/totp/enroll` to generate and return `{otpauth_uri, backup_codes}` while storing only bcrypt-hashed backup codes.
- Implemented `POST /api/v1/auth/mfa/totp/confirm` to verify first TOTP code, enable MFA on the user, and emit an `MFA_ENABLE` audit log.
- Updated login flow so MFA-enabled users receive an MFA challenge token instead of immediate session tokens.
- Implemented `POST /api/v1/auth/mfa/verify` to validate TOTP/backup code and complete login by issuing access/refresh tokens.
- Added migration `0007_create_mfa_totp_credentials` and comprehensive token + integration tests for MFA flow and backup-code one-time use.
Key decisions / gotchas:
- Introduced short-lived JWT MFA challenge tokens (`purpose=mfa`) to keep the login and MFA verification steps stateless.
- Kept backup codes server-side as bcrypt hashes only; normalized codes during verification to make one-time consumption deterministic.
- Kept existing AUTH-002 behavior unchanged for non-MFA users by making login response token fields nullable only when MFA is required.
Files created/modified: packages/backend/app/models/mfa_totp_credential.py, packages/backend/alembic/versions/0007_create_mfa_totp_credentials.py, packages/backend/app/db/model_registry.py, packages/backend/app/core/settings.py, packages/backend/app/security/tokens.py, packages/backend/app/services/auth.py, packages/backend/app/schemas/auth.py, packages/backend/app/api/v1/auth.py, packages/backend/tests/test_auth_mfa_integration.py, packages/backend/tests/test_auth_tokens_unit.py, packages/backend/pyproject.toml, prd.json, progress.txt
---
---
[AUTH-005] — JWT auth middleware / FastAPI dependency
Date: 2026-02-20
What was done:
- Added shared auth dependencies: `get_access_token`, `get_current_user`, `require_role`, and `require_admin`.
- Updated protected auth endpoints to use dependency injection for bearer JWT validation instead of manual header parsing.
- Added unit tests covering valid token access, expired-token 401 with `WWW-Authenticate: Bearer`, and role-based 403 denial for admin-only route.
- Kept session/MFA service methods backward-compatible by supporting either dependency-provided `current_user` or access-token lookup.
Key decisions / gotchas:
- Implemented role guard as hierarchical (`viewer < member < manager < admin < owner`) so higher-privileged roles satisfy lower-role requirements.
- Continued using centralized token validation (`validate_access_token`) to enforce RS256 signature, issuer, and expiry checks in one place.
Files created/modified: packages/backend/app/api/dependencies/__init__.py, packages/backend/app/api/dependencies/auth.py, packages/backend/app/api/v1/auth.py, packages/backend/app/services/auth.py, packages/backend/tests/test_auth_dependencies_unit.py, prd.json, progress.txt
---
---
[VAULT-001] — Create vault item endpoint
Date: 2026-02-20
What was done:
- Added `POST /api/v1/vault/items` protected by `get_current_user` JWT dependency.
- Implemented vault item creation service that stores `encrypted_data` and `encrypted_key` verbatim and never decodes/decrypts them.
- Added audit logging on create with `action=CREATE_ITEM` and `target_id` set to the created item.
- Added unit and integration tests covering happy path persistence/audit behavior and unauthorized access.
- Imported model registry during app startup so SQLAlchemy metadata resolves cross-model foreign keys at runtime.
Key decisions / gotchas:
- Used a dedicated `vault` schema/service/router split to keep endpoint validation, business logic, and API wiring clean.
- Integration test schema needs the `folders` table present because `vault_items.folder_id` has a foreign key reference.
Files created/modified: packages/backend/app/schemas/vault.py, packages/backend/app/services/vault.py, packages/backend/app/api/v1/vault.py, packages/backend/app/main.py, packages/backend/tests/test_vault_create_unit.py, packages/backend/tests/test_vault_create_integration.py, prd.json, progress.txt
---
---
[VAULT-002] — Get, update, and soft-delete vault item endpoints
Date: 2026-02-20
What was done:
- Added protected `GET /api/v1/vault/items/{id}`, `PUT /api/v1/vault/items/{id}`, and `DELETE /api/v1/vault/items/{id}` endpoints using `get_current_user`.
- Implemented owner-scoped access checks with explicit `403` for cross-user access and `404` for missing/soft-deleted items.
- Added update flow that snapshots prior encrypted blobs into `vault_item_revisions`, increments revision number, and prunes to the last 10 revisions.
- Implemented soft-delete by setting `deleted_at` (and `updated_at`) without hard deletion.
- Added audit logging for `view_item`, `edit_item`, and `delete_item` actions.
- Added integration test coverage for lifecycle behavior, revision retention, audit actions, and the `403` case.
Key decisions / gotchas:
- Reused the existing pattern of storing encrypted blobs verbatim and never decoding/decrypting server-side.
- Treated soft-deleted items as not found in active-item lookups so they are excluded from subsequent item retrieval/sync paths.
- Used UUID normalization in integration assertions because SQLite test storage can differ in UUID formatting.
Files created/modified: packages/backend/app/services/vault.py, packages/backend/app/api/v1/vault.py, packages/backend/app/schemas/vault.py, packages/backend/tests/test_vault_item_lifecycle_integration.py, prd.json, progress.txt
---
---
[VAULT-003] — Full vault sync and delta sync endpoints
Date: 2026-02-20
What was done:
- Added `GET /api/v1/vault` with owner-scoped pagination (`limit`, `offset`) returning only non-deleted vault items.
- Added `GET /api/v1/vault/sync?since=<ISO8601>` with owner-scoped delta filtering on `updated_at` and exclusion of soft-deleted items.
- Added `X-Vault-Revision` response header on both endpoints using a monotonic revision counter derived from the latest vault item `updated_at` for the user.
- Added integration coverage that seeds 125 items and validates pagination, delta correctness, and deleted-item exclusion.
- Added paginated vault response schema and wired new service-layer list/sync methods.
Key decisions / gotchas:
- Implemented UUID comparison with normalized `lower(replace(...))` matching to keep behavior consistent between SQLite tests and MySQL UUID storage formats.
- Normalized timestamp parsing in sync filtering to avoid SQLite text/datetime comparison edge cases while preserving MySQL-compatible behavior.
Files created/modified: packages/backend/app/api/v1/vault.py, packages/backend/app/services/vault.py, packages/backend/app/schemas/vault.py, packages/backend/tests/test_vault_sync_integration.py, prd.json, progress.txt
---
---
[VAULT-004] — Vault item revision history and restore endpoints
Date: 2026-02-20
What was done:
- Added `GET /api/v1/vault/items/{id}/history` to return revision history entries with `revision_number` and `created_at`.
- Added `POST /api/v1/vault/items/{id}/restore` to restore a selected revision while first snapshotting current encrypted state as a new revision.
- Added restore audit logging (`restore_item`) and an Alembic migration to extend the audit enum in MySQL.
- Added integration coverage validating history listing before/after restore, restored ciphertext values, and restore audit emission.
Key decisions / gotchas:
- Restore behavior only rewrites `encrypted_data`/`encrypted_key` because revision records store encrypted blobs, while item metadata remains unchanged.
- Reused existing revision-pruning policy (keep last 10) during restore so revision retention stays consistent with update semantics.
Files created/modified: packages/backend/app/api/v1/vault.py, packages/backend/app/services/vault.py, packages/backend/app/schemas/vault.py, packages/backend/app/models/audit_log.py, packages/backend/alembic/versions/0008_add_restore_item_audit_action.py, packages/backend/tests/test_vault_restore_history_integration.py, prd.json, progress.txt
---
