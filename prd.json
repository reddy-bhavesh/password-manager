{
  "project": "VaultGuard — Enterprise Password Manager",
  "version": "1.0.0",
  "description": "Atomic development tasks derived from the PDR. Each task is designed to be completable within a single AI context window. Tasks are ordered by dependency — complete them in sequence.",
  "phases": {
    "phase1": "MVP (Months 1–4)",
    "phase2": "Enterprise (Months 5–8)",
    "phase3": "Advanced (Months 9–12)"
  },
  "stories": [
    {
      "id": "INFRA-001",
      "phase": 1,
      "title": "Initialize monorepo with Turborepo",
      "description": "Bootstrap the project monorepo structure using Turborepo. Create the workspace layout: apps/web, apps/extension, services/auth, services/vault, services/org, services/audit, packages/crypto, packages/shared-types. Add root package.json, turbo.json, and .gitignore.",
      "acceptanceCriteria": [
        "Turborepo monorepo initialized with `npx create-turbo`",
        "apps/web and services/* directories scaffolded",
        "packages/crypto and packages/shared-types directories exist",
        "Root turbo.json has build, dev, lint, test pipelines defined",
        "`turbo run build` runs without errors on empty workspaces"
      ],
      "passes": true
    },

    {
      "id": "INFRA-002",
      "phase": 1,
      "title": "Docker Compose dev environment",
      "description": "Create a docker-compose.dev.yml that spins up: MySQL 8.0, Redis 7, MinIO (S3-compatible), and Meilisearch. Include health checks for each service. Create a .env.example with all required environment variables.",
      "acceptanceCriteria": [
        "docker-compose.dev.yml exists with MySQL 8.0, Redis 7, MinIO, Meilisearch services",
        "Each service has a healthcheck defined",
        ".env.example documents all required env vars",
        "`docker compose -f docker-compose.dev.yml up -d` starts all services successfully",
        "MySQL is accessible on port 3306, Redis on 6379, MinIO on 9000"
      ],
      "passes": true
    },

    {
      "id": "INFRA-003",
      "phase": 1,
      "title": "Initialize Go backend (Auth Service)",
      "description": "Initialize the auth service Go module under services/auth using Go 1.22+ and Gin framework. Set up the project structure: cmd/server/main.go, internal/handler, internal/service, internal/repository, internal/middleware. Configure golang-migrate for MySQL migrations. Add a health-check endpoint GET /health.",
      "acceptanceCriteria": [
        "Go module initialized at services/auth with `go mod init`",
        "Gin server starts and listens on configurable PORT env var",
        "GET /health returns 200 OK with JSON `{\"status\": \"ok\"}`",
        "golang-migrate dependency added and migration directory created at services/auth/migrations/",
        "`go build ./...` passes with no errors"
      ],
      "passes": false
    },

    {
      "id": "INFRA-004",
      "phase": 1,
      "title": "Database schema — core tables migration",
      "description": "Create the initial MySQL migration file (001_initial_schema.up.sql) for the core entities: organizations, users, vault_items, vault_item_revisions, folders, collections, collection_members, audit_logs. Use UUIDs as primary keys. Apply the migration via golang-migrate.",
      "acceptanceCriteria": [
        "Migration file 001_initial_schema.up.sql exists and is valid SQL",
        "All tables created: organizations, users, vault_items, vault_item_revisions, folders, collections, collection_members, audit_logs",
        "All primary keys are CHAR(36) UUID columns",
        "Appropriate foreign keys, indexes, and NOT NULL constraints are present",
        "Corresponding 001_initial_schema.down.sql can cleanly roll back",
        "`go run ./cmd/migrate up` runs the migration successfully against local MySQL"
      ],
      "passes": false
    },

    {
      "id": "INFRA-005",
      "phase": 1,
      "title": "Initialize React + TypeScript frontend (apps/web)",
      "description": "Initialize the web frontend under apps/web using Vite 6 + React 19 + TypeScript. Install core dependencies: Zustand, TanStack Query, TanStack Router, React Hook Form, Zod, Radix UI, Framer Motion. Set up the design system CSS variables (colors, typography, border radius) from PDR Section 12.2. Add Inter font from Google Fonts.",
      "acceptanceCriteria": [
        "Vite + React 19 + TypeScript project initialized at apps/web",
        "All specified dependencies installed without peer dep conflicts",
        "Design system tokens defined in src/styles/tokens.css (primary #1A1F36, accent #6C63FF, etc.)",
        "Inter font loaded via Google Fonts in index.html",
        "`npm run dev` starts dev server without errors",
        "`npm run build` produces a valid production build"
      ],
      "passes": false
    },

    {
      "id": "CRYPTO-001",
      "phase": 1,
      "title": "Client-side crypto package (packages/crypto)",
      "description": "Create the packages/crypto library using libsodium.js (WASM). Implement and export these functions: deriveKeys(masterPassword, email, iterations) using Argon2id (64MB memory, 3 iterations, parallelism 4) → returns { encryptionKey, macKey }. encryptItem(plaintext, key) → { ciphertext, nonce } using XSalsa20-Poly1305. decryptItem(ciphertext, nonce, key) → plaintext. generateKeyPair() → { publicKey, secretKey } X25519 key pair. encryptDEK(dek, recipientPublicKey) and decryptDEK(encryptedDek, secretKey).",
      "acceptanceCriteria": [
        "packages/crypto exports all 6 functions with TypeScript types",
        "libsodium-wrappers-sumo installed as dependency",
        "deriveKeys uses argon2id with memory=65536 (64MB), opslimit=3, parallelism=4",
        "encryptItem / decryptItem round-trip test passes (encrypt then decrypt returns original)",
        "generateKeyPair produces valid X25519 key pair",
        "encryptDEK / decryptDEK round-trip test passes",
        "All functions are async (libsodium needs await sodium.ready)"
      ],
      "passes": false
    },

    {
      "id": "CRYPTO-002",
      "phase": 1,
      "title": "Crypto unit tests with known-answer tests (KATs)",
      "description": "Write comprehensive unit tests for packages/crypto using Vitest. Include known-answer tests (KATs) for each function: test with fixed inputs and assert exact expected outputs. Test error cases: wrong key, tampered ciphertext, invalid nonce lengths.",
      "acceptanceCriteria": [
        "Vitest configured for packages/crypto",
        "KAT test for deriveKeys with fixed password/email/iterations produces deterministic output",
        "KAT test for encryptItem/decryptItem with fixed key produces expected ciphertext",
        "Tampered ciphertext throws an error on decryptItem",
        "Wrong key on decryptDEK throws an error",
        "`vitest run` shows 100% pass rate on crypto package"
      ],
      "passes": false
    },

    {
      "id": "CRYPTO-003",
      "phase": 1,
      "title": "Go backend cryptography utilities",
      "description": "Create the internal/crypto package in the auth service. Implement: hashPassword(password) using Argon2id (memory=65536, time=3, threads=4, keyLen=32) for server-side auth token hashing (NOT master password), verifyPassword(hash, password), generateSecureToken(byteLen) using crypto/rand, generateUUID() using google/uuid.",
      "acceptanceCriteria": [
        "internal/crypto package in services/auth created",
        "hashPassword / verifyPassword round-trip test passes",
        "Argon2id parameters exactly match PDR spec (memory=64MB, time=3, threads=4)",
        "generateSecureToken(32) returns a 32-byte crypto-random token",
        "`go test ./internal/crypto/...` passes with 100% coverage on all exported functions"
      ],
      "passes": false
    },

    {
      "id": "AUTH-001",
      "phase": 1,
      "title": "User registration & KDF parameters endpoint",
      "description": "Implement user registration and the preauth endpoint in the auth service. POST /api/v1/auth/register accepts { email, orgName, publicKey, encryptedPrivateKey, kdfParams }. POST /api/v1/auth/preauth accepts { email } and returns the user's KDF parameters (iterations, memory, salt) needed by the client before login. Store users in the MySQL users table.",
      "acceptanceCriteria": [
        "POST /api/v1/auth/register creates user and organization records in the DB",
        "Returns 409 if email already exists",
        "POST /api/v1/auth/preauth returns { kdfIterations, kdfMemory, kdfSalt } for a known email",
        "Returns 404 for unknown email (do not leak user existence — return generic message)",
        "Input validation rejects malformed emails and missing fields with 400",
        "sqlc-generated query or raw parameterized query used (no string concatenation)"
      ],
      "passes": false
    },

    {
      "id": "AUTH-002",
      "phase": 1,
      "title": "Login endpoint & JWT token issuance",
      "description": "Implement POST /api/v1/auth/login. Accept { email, authKey } where authKey is derived client-side from the master password (never the master password itself). Verify the authKey hash. On success, issue: an access token (JWT RS256, 15-min TTL) and a refresh token (opaque, stored in DB, 7-day TTL). Also return the user's encrypted_private_key and public_key so the client can decrypt the vault.",
      "acceptanceCriteria": [
        "POST /api/v1/auth/login with correct credentials returns { accessToken, refreshToken, user: { encryptedPrivateKey, publicKey } }",
        "accessToken is a valid RS256 JWT with exp=15min and correct claims",
        "refreshToken is stored in a sessions table with user_id, expires_at, revoked=false",
        "Returns 401 for invalid credentials",
        "Rate limiting: after 5 failed attempts, account locked for 15 minutes (NIST SP 800-63B)",
        "Failed login event written to audit_logs table"
      ],
      "passes": false
    },

    {
      "id": "AUTH-003",
      "phase": 1,
      "title": "Token refresh & logout endpoints",
      "description": "Implement POST /api/v1/auth/refresh and POST /api/v1/auth/logout. Refresh rotates the refresh token (old token invalidated, new token issued with new 7-day TTL). Logout revokes the session. Implement JWT validation middleware that checks signature, expiry, and blacklist.",
      "acceptanceCriteria": [
        "POST /api/v1/auth/refresh with valid refresh token returns new { accessToken, refreshToken }",
        "Old refresh token is marked revoked=true in the DB after use",
        "Reuse of a revoked refresh token returns 401",
        "POST /api/v1/auth/logout marks session as revoked",
        "JWT middleware correctly rejects expired tokens, bad signatures, and revoked sessions",
        "`go test ./internal/handler/auth_test.go` passes all test cases"
      ],
      "passes": false
    },

    {
      "id": "AUTH-004",
      "phase": 1,
      "title": "TOTP MFA implementation",
      "description": "Implement TOTP (RFC 6238) MFA in the auth service. Endpoints: POST /api/v1/auth/mfa/setup (returns QR code seed), POST /api/v1/auth/mfa/confirm (validate first TOTP code and enable MFA), POST /api/v1/auth/mfa/verify (complete login MFA step). Login flow for MFA users: login returns { mfaRequired: true, mfaToken }, then /mfa/verify accepts { mfaToken, totpCode } and returns the full JWT pair.",
      "acceptanceCriteria": [
        "POST /api/v1/auth/mfa/setup returns a valid TOTP secret and otpauth:// URI",
        "TOTP secret stored encrypted in users.mfa_secret column",
        "POST /api/v1/auth/mfa/confirm validates the first code before enabling MFA",
        "Login for MFA-enabled user returns { mfaRequired: true, mfaToken } (no JWT yet)",
        "POST /api/v1/auth/mfa/verify accepts mfaToken + TOTP code and returns full JWT pair",
        "TOTP replay protection: used codes cannot be reused within 30-second window"
      ],
      "passes": false
    },

    {
      "id": "AUTH-005",
      "phase": 1,
      "title": "Session management — list & revoke sessions",
      "description": "Implement GET /api/v1/auth/sessions (list all active sessions for current user with device info, IP, last used) and DELETE /api/v1/auth/sessions/{id} (revoke a specific session). Capture user_agent and ip_address on login and store in sessions table.",
      "acceptanceCriteria": [
        "GET /api/v1/auth/sessions returns active sessions with { id, deviceInfo, ipAddress, lastUsed, isCurrent }",
        "DELETE /api/v1/auth/sessions/{id} marks session revoked, returns 204",
        "Cannot revoke another user's session (403)",
        "Sessions table has user_agent and ip_address columns populated on login",
        "Protected by JWT middleware"
      ],
      "passes": false
    },

    {
      "id": "VAULT-001",
      "phase": 1,
      "title": "Initialize Go Vault Service",
      "description": "Initialize the vault service Go module under services/vault with the same structure as auth service (cmd/server, internal/handler, internal/service, internal/repository). Share the same MySQL database. Configure JWT validation middleware (same RS256 public key as auth service). Add GET /health endpoint.",
      "acceptanceCriteria": [
        "services/vault Go module initialied",
        "JWT middleware validates RS256 tokens from auth service (shared public key via env var)",
        "GET /health returns 200 OK",
        "`go build ./...` passes in services/vault"
      ],
      "passes": false
    },

    {
      "id": "VAULT-002",
      "phase": 1,
      "title": "Create & retrieve vault items",
      "description": "Implement CRUD endpoints for vault items. POST /api/v1/vault/items accepts { type, name, encryptedData, encryptedKey, folderId? }. GET /api/v1/vault/items/{id} returns the item and writes an audit log entry for 'view_item'. Item types: login, note, card, identity, ssh_key, api_token, file. All data stored as encrypted blobs — service never decrypts.",
      "acceptanceCriteria": [
        "POST /api/v1/vault/items creates a new vault_item record and returns it with a generated UUID",
        "All enum values for type are validated (400 for unknown type)",
        "GET /api/v1/vault/items/{id} returns the item for the owner only (403 for other users)",
        "GET /api/v1/vault/items/{id} writes a view_item audit log entry",
        "encryptedData stored as LONGBLOB, encryptedKey as BLOB",
        "Auth required on all endpoints"
      ],
      "passes": false
    },

    {
      "id": "VAULT-003",
      "phase": 1,
      "title": "Update, soft-delete & list vault items",
      "description": "Implement remaining vault item endpoints: PUT /api/v1/vault/items/{id} (update, creates a revision), DELETE /api/v1/vault/items/{id} (soft delete — sets deleted_at), GET /api/v1/vault (full vault sync — returns all non-deleted items for the user), GET /api/v1/vault/sync?since= (delta sync — items updated after timestamp).",
      "acceptanceCriteria": [
        "PUT /api/v1/vault/items/{id} updates the item and creates a vault_item_revision record",
        "DELETE /api/v1/vault/items/{id} sets deleted_at timestamp (soft delete)",
        "GET /api/v1/vault returns all items where owner_id = current user AND deleted_at IS NULL",
        "GET /api/v1/vault/sync?since=<ISO8601> returns items updated after the given timestamp",
        "Audit log entries written for edit_item and delete_item actions",
        "Only item owner can update/delete (403 otherwise)"
      ],
      "passes": false
    },

    {
      "id": "VAULT-004",
      "phase": 1,
      "title": "Vault item revision history",
      "description": "Implement version history endpoints: GET /api/v1/vault/items/{id}/history (list last 10 revisions) and POST /api/v1/vault/items/{id}/restore (restore a specific revision by revision_number, creating a new revision of the current state first).",
      "acceptanceCriteria": [
        "GET /api/v1/vault/items/{id}/history returns last 10 revisions ordered by revision_number DESC",
        "Each revision includes revision_number, created_at, encryptedData, encryptedKey",
        "POST /api/v1/vault/items/{id}/restore with { revisionNumber } saves the current as a new revision then sets the item to the requested revision's data",
        "Revision limit of 10 enforced: oldest revision pruned when limit exceeded",
        "Returns 404 if revision_number not found"
      ],
      "passes": false
    },

    {
      "id": "VAULT-005",
      "phase": 1,
      "title": "Folder management",
      "description": "Implement folder endpoints: POST /api/v1/vault/folders (create folder with name, parentFolderId?), GET /api/v1/vault/folders (list user's folders), PUT /api/v1/vault/folders/{id} (rename), DELETE /api/v1/vault/folders/{id} (delete — items in folder become unfoldered). Support nested folders via parent_folder_id self-reference.",
      "acceptanceCriteria": [
        "Folders table has id, user_id, org_id, name, parent_folder_id, created_at columns",
        "POST /api/v1/vault/folders creates a folder for the current user",
        "GET /api/v1/vault/folders returns all folders for user, including parent_folder_id for nesting",
        "DELETE /api/v1/vault/folders/{id} sets vault_items.folder_id = NULL for items in that folder",
        "Only folder owner can modify/delete it"
      ],
      "passes": false
    },

    {
      "id": "ORG-001",
      "phase": 1,
      "title": "Initialize Go Org Service & user management",
      "description": "Initialize the org service under services/org. Implement: GET /api/v1/org (get org details), GET /api/v1/org/users (list all users in org), POST /api/v1/org/users/invite (send email invitation with magic link token), DELETE /api/v1/org/users/{id} (offboard user — suspend account, revoke all sessions). RBAC: only Owner/Admin can invite/offboard.",
      "acceptanceCriteria": [
        "services/org Go module initialized with JWT middleware",
        "GET /api/v1/org returns organization name, tier, created_at",
        "GET /api/v1/org/users returns users with id, email, name, role, status",
        "POST /api/v1/org/users/invite creates an invited user record, generates magic link token, writes to a user_invitations table",
        "DELETE /api/v1/org/users/{id} sets user.status = 'suspended' and revokes all their sessions",
        "Returns 403 if caller is not Owner or Admin"
      ],
      "passes": false
    },

    {
      "id": "ORG-002",
      "phase": 1,
      "title": "User invitation acceptance flow",
      "description": "Implement the invitation acceptance endpoint: POST /api/v1/auth/accept-invite accepts { token, name, publicKey, encryptedPrivateKey, kdfParams } — validates the magic link token (expires in 72h), creates the full user account, and returns JWT tokens. The invited user sets up their master password and keys during this step.",
      "acceptanceCriteria": [
        "user_invitations table has token (CHAR(64)), user_id, expires_at, used_at columns",
        "POST /api/v1/auth/accept-invite validates token has not expired and not used",
        "On success: updates user record with name, publicKey, encryptedPrivateKey, kdfParams, status='active'",
        "Marks invitation as used (sets used_at)",
        "Returns JWT access + refresh token pair",
        "Returns 400 for expired or already-used tokens"
      ],
      "passes": false
    },

    {
      "id": "ORG-003",
      "phase": 1,
      "title": "Role management & RBAC middleware",
      "description": "Implement PATCH /api/v1/org/users/{id}/role (change a user's role). Create a reusable RBAC middleware for Go services: requireRole(roles ...string) that reads the user's role from JWT claims and returns 403 if insufficient. Predefined roles: owner > admin > manager > member > viewer. Apply RBAC to all sensitive org and vault endpoints.",
      "acceptanceCriteria": [
        "PATCH /api/v1/org/users/{id}/role accepts { role } and updates the user record",
        "Owner cannot have their role changed",
        "Only org Owner can assign Owner/Admin roles",
        "requireRole middleware returns 403 with { error: 'insufficient_permissions' } for unauthorized callers",
        "Role hierarchy enforced: higher roles can perform lower-role actions",
        "Role is included in JWT claims on login"
      ],
      "passes": false
    },

    {
      "id": "AUDIT-001",
      "phase": 1,
      "title": "Initialize Go Audit Service & query audit logs",
      "description": "Initialize the audit service under services/audit. Implement: GET /api/v1/audit/logs (query audit logs with pagination, filter by actor_id, action, date range) and GET /api/v1/audit/logs/export (export as CSV or JSON via query param ?format=csv|json). Audit logs must be immutable — no UPDATE/DELETE operations allowed on audit_logs table, enforced at repo layer.",
      "acceptanceCriteria": [
        "services/audit Go module initialized",
        "GET /api/v1/audit/logs supports query params: page, pageSize, actorId, action, startDate, endDate",
        "Returns paginated results with { data, total, page, pageSize }",
        "GET /api/v1/audit/logs/export returns CSV or JSON file download",
        "Audit service repository layer has no UPDATE or DELETE methods for audit_logs",
        "Only Admin/Owner can access audit endpoints (403 otherwise)"
      ],
      "passes": false
    },

    {
      "id": "AUDIT-002",
      "phase": 1,
      "title": "Centralized audit log writer (shared package)",
      "description": "Create a shared Go package packages/auditlog (or internal/auditlog) that all services import. Expose WriteLog(ctx, entry AuditEntry) which inserts into audit_logs asynchronously (using a buffered channel + goroutine to avoid blocking request handlers). AuditEntry fields: orgId, actorId, action, targetId, ipAddress, userAgent.",
      "acceptanceCriteria": [
        "Shared auditlog package created and importable by auth, vault, org services",
        "WriteLog is non-blocking (uses buffered channel or goroutine)",
        "AuditEntry struct has all required fields matching the DB schema",
        "On service shutdown, buffer is flushed before exit",
        "If DB insert fails, error is logged to stderr (not propagated to caller)"
      ],
      "passes": false
    },

    {
      "id": "GW-001",
      "phase": 1,
      "title": "API Gateway with rate limiting & routing",
      "description": "Create a simple API gateway using NGINX (nginx.conf) or a Go reverse proxy under services/gateway. Configure: rate limiting (1000 req/min per user via X-User-ID header after auth, 10,000 req/min per org), route /api/v1/auth/* → auth service, /api/v1/vault/* → vault service, /api/v1/org/* → org service, /api/v1/audit/* → audit service. Add security headers: HSTS, X-Frame-Options, X-Content-Type-Options, CSP.",
      "acceptanceCriteria": [
        "NGINX or Go gateway configured and added to docker-compose.dev.yml",
        "Routes correctly proxy to each microservice",
        "Rate limiting configured (return 429 when exceeded)",
        "HSTS, X-Frame-Options: DENY, X-Content-Type-Options: nosniff headers present on all responses",
        "TLS termination configured (self-signed cert for dev)",
        "Health check GET /health passes through to a backend service"
      ],
      "passes": false
    },

    {
      "id": "FE-001",
      "phase": 1,
      "title": "Frontend routing & layout shell",
      "description": "Set up TanStack Router in apps/web. Define routes: / (redirect to /vault if authed, else /login), /login, /register, /accept-invite/:token, /vault, /vault/item/:id, /settings. Create the main layout shell: top navigation bar with VaultGuard logo, user menu avatar, and sidebar. Sidebar has: My Vault, Favorites, Folders (tree), Trash. Implement a persistent AuthStore (Zustand) that holds { accessToken, user, isAuthenticated }.",
      "acceptanceCriteria": [
        "TanStack Router configured with all specified routes",
        "Unauthenticated users redirected from /vault to /login",
        "Authenticated users redirected from /login to /vault",
        "Layout shell renders with navigation bar, sidebar, and main content outlet",
        "AuthStore persists to sessionStorage (not localStorage — security)",
        "`npm run build` succeeds with no TypeScript errors"
      ],
      "passes": false
    },

    {
      "id": "FE-002",
      "phase": 1,
      "title": "Login & registration UI",
      "description": "Build the login and registration pages in apps/web. Login: email + master password fields, 'Unlock Vault' button. On submit: call /api/v1/auth/preauth to get KDF params, derive authKey client-side using packages/crypto, call /api/v1/auth/login. Registration: email, org name, master password, confirm password. On submit: generate key pair, derive keys, call /api/v1/auth/register. Show loading states and error messages. TOTP MFA step if mfaRequired=true.",
      "acceptanceCriteria": [
        "Login page at /login with email and master password fields",
        "Client-side key derivation using Argon2id via packages/crypto before API call",
        "MFA step shown if API returns mfaRequired=true",
        "Registration page at /register with all required fields",
        "Password strength meter shown on registration (weak/medium/strong based on entropy)",
        "Form validation using React Hook Form + Zod (required fields, email format, password confirmation match)",
        "Error messages from API displayed in-form (not alert())"
      ],
      "passes": false
    },

    {
      "id": "FE-003",
      "phase": 1,
      "title": "Vault dashboard — item list & search",
      "description": "Build the vault dashboard at /vault. Left sidebar shows folder tree. Center panel shows a list of vault items (icon by type, name, username if login, last updated). Implement local search filtering by name. Items load via TanStack Query GET /api/v1/vault. Show loading skeleton and empty state. Clicking an item navigates to /vault/item/:id.",
      "acceptanceCriteria": [
        "Vault items fetched with TanStack Query and displayed in a scrollable list",
        "Each row shows: type icon, name, subtitle (username or note preview), last updated",
        "Search input filters the list client-side by name in real-time",
        "Loading skeleton shown while fetching",
        "Empty state message shown when vault has no items",
        "Folder sidebar filters items when folder clicked"
      ],
      "passes": false
    },

    {
      "id": "FE-004",
      "phase": 1,
      "title": "Vault item detail view — decrypt & display",
      "description": "Build the item detail panel at /vault/item/:id. Fetch item, decrypt encryptedData client-side using packages/crypto (user's derived encryption key from Zustand). Display fields based on item type: login shows username, password (masked ••••), URL, notes; note shows content; card shows card number (masked), expiry, CVV (masked). Click to reveal masked fields. One-click copy with 30-second auto-clear clipboard timer.",
      "acceptanceCriteria": [
        "Item detail fetched from GET /api/v1/vault/items/:id and decrypted client-side",
        "Password and CVV fields shown as •••• by default, revealed on button click",
        "Copy button copies plaintext to clipboard and shows '✓ Copied' confirmation",
        "Clipboard cleared after 30 seconds (configurable via clearClipboard timeout)",
        "Item type determines which fields are shown",
        "Error shown if decryption fails (wrong key)"
      ],
      "passes": false
    },

    {
      "id": "FE-005",
      "phase": 1,
      "title": "Create & edit vault item forms",
      "description": "Build the create and edit forms for vault items. 'New Item' button opens a modal or side panel. Form fields differ by type: login (name, URL, username, password, notes), note (name, content), card (name, cardholder, number, expiry, CVV). Password field has a 'Generate' button that opens the password generator. On save, encrypt client-side and POST/PUT to API.",
      "acceptanceCriteria": [
        "'New Item' button and type selector (Login, Note, Card, SSH Key, API Token, Identity) present",
        "Form fields render based on selected type",
        "Password generator button opens a generator panel with length slider and character set toggles",
        "On save: data encrypted client-side, then POST /api/v1/vault/items called",
        "On edit: existing encrypted data decrypted, form pre-filled, PUT on save",
        "Optimistic UI update or TanStack Query invalidation after save",
        "Zod validation: name required, URL must be valid URL format"
      ],
      "passes": false
    },

    {
      "id": "FE-006",
      "phase": 1,
      "title": "Password generator page/component",
      "description": "Build the standalone password generator as both a page at /generate and an embeddable component used in item forms. Options: length (8-128 slider), include uppercase, lowercase, numbers, symbols, exclude ambiguous chars toggle. Passphrase mode: word count (3-8), separator, capitalize. Display generated password in a monospace font with copy button. Generate on load and on any option change.",
      "acceptanceCriteria": [
        "Generator available at /generate and as an embeddable <PasswordGenerator /> component",
        "Length slider from 8 to 128",
        "Uppercase, lowercase, numbers, symbols toggles",
        "Exclude ambiguous characters (0O, lI1) toggle",
        "Passphrase mode with word count and separator options (using EFF word list bundled in package)",
        "Generated password displayed in JetBrains Mono font",
        "Copy button clears clipboard after 30 seconds"
      ],
      "passes": false
    },

    {
      "id": "FE-007",
      "phase": 1,
      "title": "Import from CSV & Bitwarden JSON",
      "description": "Build an import page at /settings/import. Support: Generic CSV (columns: name, url, username, password, notes), Bitwarden JSON export format. Parse client-side, map to VaultItem structures, encrypt each item, and bulk-create via multiple POST /api/v1/vault/items calls. Show a progress bar during import. Show results: N imported, N failed.",
      "acceptanceCriteria": [
        "Import page at /settings/import with file upload drag-and-drop or file picker",
        "CSV parser handles generic CSV with headers: name, url, username, password, notes",
        "Bitwarden JSON parser handles the exported format (type, login.username, login.password, etc.)",
        "Each imported item encrypted client-side before API call",
        "Progress bar shows X/Total items imported",
        "Final success/error summary shown",
        "Validation: alert user if CSV is missing required columns"
      ],
      "passes": false
    },

    {
      "id": "EXT-001",
      "phase": 1,
      "title": "Chrome extension scaffold (Manifest V3)",
      "description": "Create the Chrome browser extension under apps/extension using Vite + CRXJS + React + TypeScript (Manifest V3). Set up: manifest.json (permissions: storage, activeTab, scripting), popup.html/popup.tsx (320x480px), background service worker (background.ts), content script (content.ts). Share packages/crypto from the monorepo. Add extension to Turborepo build pipeline.",
      "acceptanceCriteria": [
        "apps/extension directory with valid manifest.json (Manifest V3)",
        "Popup opens as a 320x480px React app",
        "Background service worker registered",
        "Content script injected on all http:// and https:// pages",
        "`npm run build` in apps/extension produces a dist/ folder loadable as an unpacked extension in Chrome",
        "Extension imports packages/crypto from the monorepo workspace"
      ],
      "passes": false
    },

    {
      "id": "EXT-002",
      "phase": 1,
      "title": "Extension popup — login & vault display",
      "description": "Build the extension popup UI. States: (1) Logged-out: show 'Open VaultGuard' button and 'Unlock' button. (2) Locked: master password input to unlock vault (derive keys in extension). (3) Unlocked: show list of matching credentials for current tab domain, search box, and a 'Generate Password' tab. Vault data loaded from the web app shared session via storage.session.",
      "acceptanceCriteria": [
        "Popup shows correct state: logged-out, locked, or unlocked based on stored session token",
        "Unlock screen: master password input, derives keys using packages/crypto",
        "Matched credentials for current tab's hostname shown prominently",
        "Search box filters all vault items by name or URL",
        "Generate Password tab opens the password generator UI",
        "Popup auto-locks after 5 minutes of inactivity"
      ],
      "passes": false
    },

    {
      "id": "EXT-003",
      "phase": 1,
      "title": "Extension — auto-detect & auto-fill forms",
      "description": "Implement the content script for form detection and auto-fill. Content script scans the DOM for login forms (password input fields). When found, inject a small VaultGuard icon into or near the password field. On icon click, send a message to the background worker to get matching credentials, then fill username and password fields. Phishing protection: warn if current URL's domain doesn't exactly match the saved URI.",
      "acceptanceCriteria": [
        "Content script detects pages with input[type=password] fields",
        "VaultGuard icon injected near password fields",
        "Clicking icon shows a small credential picker for the current domain",
        "Selecting a credential fills the username and password fields",
        "Phishing check: if current domain != saved URI domain, show warning banner before filling",
        "Auto-fill works on Chrome on amazon.com, github.com, google.com (test sites)"
      ],
      "passes": false
    },

    {
      "id": "EXT-004",
      "phase": 1,
      "title": "Extension — save new & changed credentials",
      "description": "Implement credential save prompting in the content script. After a successful form submission (detect via form submit event or navigation), check if the submitted credentials match any saved item. If no match: show a toast/bar asking 'Save this password to VaultGuard?'. If credentials changed: 'Update saved password?'. On confirm, encrypt and save via the API.",
      "acceptanceCriteria": [
        "Form submit event listener detects username/password pairs on submit",
        "Save prompt shown if no matching credential exists for the domain",
        "Update prompt shown if credential exists but password changed",
        "User can dismiss prompt permanently for a domain ('Never save for this site')",
        "Ignored sites list stored in extension storage.sync",
        "On confirm, item encrypted client-side and POSTed to API"
      ],
      "passes": false
    },

    {
      "id": "SEC-001",
      "phase": 1,
      "title": "HaveIBeenPwned breach detection (k-anonymity)",
      "description": "Implement breach detection using the HIBP Pwned Passwords API with k-anonymity. In the web app: when a user views a login item, check if the password has been breached. Client-side: SHA-1 hash the password, send the first 5 chars to https://api.pwnedpasswords.com/range/{prefix}, check if the hash suffix appears in the response. Display a red warning badge if breached.",
      "acceptanceCriteria": [
        "SHA-1 of password computed client-side (SubtleCrypto API)",
        "Only first 5 hex chars sent to HIBP API (k-anonymity preserved)",
        "Response parsed to check if hash suffix is present",
        "Red '⚠ Breached' badge shown on item if breach count > 0",
        "Check runs on item detail view open (not bulk — to avoid rate limiting)",
        "Gracefully handles HIBP API being unavailable (no error shown to user, badge hidden)"
      ],
      "passes": false
    },

    {
      "id": "SEC-002",
      "phase": 1,
      "title": "Weak & reused password detection",
      "description": "In the web app, implement client-side password health analysis across all decrypted vault items. After full vault sync and decryption, compute: (1) weak passwords — zxcvbn score < 2, (2) reused passwords — group by identical password value. Store results in a PasswordHealthStore (Zustand). Show badge counts in sidebar. Create a /security page that lists weak and reused passwords.",
      "acceptanceCriteria": [
        "zxcvbn library used for password strength scoring",
        "Passwords with zxcvbn score 0 or 1 classified as weak",
        "Passwords shared by 2+ items classified as reused",
        "PasswordHealthStore holds { weakPasswords: VaultItem[], reusedGroups: VaultItem[][] }",
        "Sidebar shows 'Security' nav item with a count badge (e.g., '5 issues')",
        "/security page lists weak passwords and reused password groups with quick-navigate links to each item"
      ],
      "passes": false
    },

    {
      "id": "DEPLOY-001",
      "phase": 1,
      "title": "Production Docker Compose & Dockerfiles",
      "description": "Create production Dockerfiles for each service (auth, vault, org, audit, web). Multi-stage builds for Go services (builder → distroless base). Multi-stage build for React frontend (node builder → nginx static). Create docker-compose.prod.yml with all services, proper env var references, and no exposed dev ports. Add a setup.sh script that generates a random JWT key pair on first run.",
      "acceptanceCriteria": [
        "Dockerfile exists for each service with multi-stage build",
        "Go service images based on gcr.io/distroless/base-nossl",
        "Frontend image uses nginx:alpine to serve static files",
        "docker-compose.prod.yml does not expose MySQL/Redis ports externally",
        "setup.sh generates RSA key pair for JWT signing if not already present",
        "`docker compose -f docker-compose.prod.yml up --build` starts all services"
      ],
      "passes": false
    },

    {
      "id": "DEPLOY-002",
      "phase": 1,
      "title": "CI/CD pipeline (GitHub Actions)",
      "description": "Create GitHub Actions workflows: (1) .github/workflows/ci.yml — on PR: run `go test` for all services, `vitest run` for frontend/packages, run golangci-lint, run `npm run build`. (2) .github/workflows/security.yml — on PR: run govulncheck, npm audit, Trivy container scan. Both workflows must pass before merge.",
      "acceptanceCriteria": [
        ".github/workflows/ci.yml runs tests for all Go services and frontend packages",
        ".github/workflows/security.yml runs govulncheck, npm audit --audit-level=high, Trivy",
        "Trivy blocks on HIGH or CRITICAL CVEs",
        "golangci-lint runs with OWASP-relevant rules enabled",
        "Workflow succeeds on a clean build",
        "PRs show workflow status checks"
      ],
      "passes": false
    },

    {
      "id": "ENT-001",
      "phase": 2,
      "title": "Groups management",
      "description": "Implement group endpoints in the org service: POST /api/v1/org/groups (create group with name), GET /api/v1/org/groups (list groups with member count), POST /api/v1/org/groups/{id}/members (add user to group), DELETE /api/v1/org/groups/{id}/members/{userId} (remove user). Add a user_groups join table to the DB.",
      "acceptanceCriteria": [
        "user_groups table: group_id, user_id, added_at, added_by",
        "CRUD endpoints for groups implemented with proper RBAC",
        "GET /api/v1/org/groups returns groups with member count",
        "A user can belong to multiple groups",
        "Only Admin/Owner can manage groups"
      ],
      "passes": false
    },

    {
      "id": "ENT-002",
      "phase": 2,
      "title": "Shared collections (team vaults)",
      "description": "Implement shared collections. POST /api/v1/org/collections (create collection), POST /api/v1/org/collections/{id}/items (share a vault item to a collection — re-encrypts DEK for all collection members), GET /api/v1/org/collections (list collections visible to current user). Sharing flow: sender encrypts item's DEK with each member's public key and stores in collection_members table.",
      "acceptanceCriteria": [
        "Collections table and collection_members table have correct schema",
        "POST /api/v1/org/collections creates a collection owned by the calling user",
        "Sharing an item creates a VaultShare record with encryptedDek per recipient",
        "GET /api/v1/org/collections returns collections where user is a member",
        "All shares appear in the member's GET /api/v1/vault response",
        "Recipient can decrypt shared items using their private key to unwrap the DEK"
      ],
      "passes": false
    },

    {
      "id": "ENT-003",
      "phase": 2,
      "title": "SSO: SAML 2.0 integration",
      "description": "Add SAML 2.0 SSO support to the auth service using a Go SAML library (e.g., crewjam/saml). Endpoints: GET /api/v1/auth/sso/saml/metadata (returns SP metadata XML), GET /api/v1/auth/sso/saml/login (initiates SAML flow, redirects to IdP), POST /api/v1/auth/sso/saml/acs (assertion consumer service — receives SAML response, validates, issues JWT). Store SAML config per org (IdP metadata URL, entity ID).",
      "acceptanceCriteria": [
        "GET /api/v1/auth/sso/saml/metadata returns valid SP metadata XML",
        "GET /api/v1/auth/sso/saml/login redirects to configured IdP (testable with a mock IdP)",
        "POST /api/v1/auth/sso/saml/acs validates SAML assertion and issues JWT",
        "SAML config stored in org_sso_config table (idp_metadata_url, entity_id, certificate)",
        "SSO users auto-provisioned in the users table on first login (Just-In-Time provisioning)",
        "Signature validation enforced on all SAML responses"
      ],
      "passes": false
    },

    {
      "id": "ENT-004",
      "phase": 2,
      "title": "OIDC SSO integration",
      "description": "Add OpenID Connect SSO support. Endpoints: GET /api/v1/auth/sso/oidc/login (redirect to OIDC provider), GET /api/v1/auth/sso/oidc/callback (handle code exchange, validate ID token, issue JWT). Support standard OIDC providers: Okta, Azure AD, Google Workspace. Store OIDC config per org (client_id, client_secret, issuer_url).",
      "acceptanceCriteria": [
        "OIDC authorization code flow implemented",
        "ID token signature validated against provider's JWKS",
        "State parameter used to prevent CSRF on callback",
        "OIDC users auto-provisioned (same as SAML JIT provisioning)",
        "Org OIDC config stored in org_sso_config table alongside SAML config",
        "Tested with at least one real OIDC provider (e.g., Google) in dev environment"
      ],
      "passes": false
    },

    {
      "id": "ENT-005",
      "phase": 2,
      "title": "SCIM 2.0 user provisioning",
      "description": "Implement a SCIM 2.0 endpoint in the org service to allow identity providers to automatically provision and deprovision users. Implement: GET /scim/v2/Users, POST /scim/v2/Users, GET /scim/v2/Users/{id}, PUT /scim/v2/Users/{id}, PATCH /scim/v2/Users/{id}, DELETE /scim/v2/Users/{id}. Authentication via Bearer token stored in org settings.",
      "acceptanceCriteria": [
        "SCIM endpoints follow RFC 7643 and RFC 7644 schemas",
        "POST /scim/v2/Users creates a user and sends them an invitation email",
        "DELETE /scim/v2/Users/{id} suspends the user (does not hard delete)",
        "PATCH supports replace operation for userName, displayName, active fields",
        "SCIM authentication uses a separate org-level SCIM token (not user JWT)",
        "All SCIM requests and responses use application/scim+json content type"
      ],
      "passes": false
    },

    {
      "id": "ENT-006",
      "phase": 2,
      "title": "WebAuthn / FIDO2 hardware key MFA",
      "description": "Add WebAuthn (FIDO2) as an MFA option. Endpoints: POST /api/v1/auth/mfa/webauthn/register/begin, POST /api/v1/auth/mfa/webauthn/register/complete, POST /api/v1/auth/mfa/webauthn/login/begin, POST /api/v1/auth/mfa/webauthn/login/complete. Use a Go WebAuthn library (e.g., go-webauthn/webauthn). Store credential IDs in a webauthn_credentials table.",
      "acceptanceCriteria": [
        "WebAuthn registration flow completes successfully in Chrome",
        "WebAuthn authentication flow completes and issues JWT",
        "webauthn_credentials table stores credential_id, public_key, sign_count, user_id",
        "Sign count checked and updated on each authentication (prevents cloned authenticator)",
        "Multiple hardware keys can be registered per user",
        "Fallback to TOTP available if WebAuthn fails"
      ],
      "passes": false
    },

    {
      "id": "ENT-007",
      "phase": 2,
      "title": "Security dashboard (admin panel)",
      "description": "Build the admin security dashboard at /admin/security in the web app. Show: total users, MFA adoption rate (%), weak password count, breached credential count, failed login attempts (last 24h), security health score (0-100). Fetch aggregate stats from GET /api/v1/audit/reports/security. Only accessible to Admin/Owner roles. Add a basic admin panel structure with a nav sidebar.",
      "acceptanceCriteria": [
        "/admin route shows 403 for non-admin/owner users",
        "Security dashboard shows all 6 metrics with appropriate charts/indicators",
        "Security health score computed from: MFA rate (30%), no breached creds (30%), no weak passwords (20%), no failed login spikes (20%)",
        "GET /api/v1/audit/reports/security endpoint returns aggregate stats",
        "Dashboard auto-refreshes every 60 seconds",
        "Mobile-responsive layout"
      ],
      "passes": false
    },

    {
      "id": "ENT-008",
      "phase": 2,
      "title": "IP allowlist & device trust",
      "description": "Implement IP allowlist per organization. In the auth service, on each login/request, check if the client's IP is on the org's allowlist (if configured). Also implement device trust: on first login from a new device (new user_agent fingerprint), send an email 'New device login detected — was this you?' with a revoke link. Store trusted devices in a trusted_devices table.",
      "acceptanceCriteria": [
        "org_ip_allowlist table: org_id, cidr_range, created_by, created_at",
        "If an org has allowlist entries, requests from non-allowlisted IPs return 403",
        "trusted_devices table: id, user_id, device_fingerprint, trusted_at",
        "New device fingerprint (hash of user_agent + os + browser) triggers notification email",
        "Email contains a 'This wasn't me — revoke access' link that calls DELETE /api/v1/auth/sessions/{id}",
        "Allowlist management endpoints in org service (Admin/Owner only)"
      ],
      "passes": false
    },

    {
      "id": "ENT-009",
      "phase": 2,
      "title": "CLI tool (vaultguard)",
      "description": "Build the `vaultguard` CLI tool under apps/cli using Go + cobra library. Commands: vaultguard login (interactive), vaultguard vault list, vaultguard vault get <name> [--field password], vaultguard vault get <name> --copy (copy to clipboard), vaultguard generate [--length 20] [--symbols]. Authenticate via the REST API, store session token in OS keychain (using go-keyring). Output in plain text and --json flag for JSON.",
      "acceptanceCriteria": [
        "Go cobra CLI project initialized at apps/cli",
        "vaultguard login prompts for email + master password, authenticates, stores token in OS keychain",
        "vaultguard vault list outputs table of vault item names and types",
        "vaultguard vault get <name> --field password outputs the decrypted password",
        "vaultguard vault get <name> --copy copies to clipboard without printing",
        "vaultguard generate --length 20 --symbols outputs a generated password",
        "Builds on macOS, Linux, and Windows (cross-compile in CI)"
      ],
      "passes": false
    },

    {
      "id": "ENT-010",
      "phase": 2,
      "title": "Kubernetes Helm chart",
      "description": "Create a Helm chart at deploy/helm/vaultguard/. Include templates for: Deployment and Service for each microservice, MySQL StatefulSet (or external DB option), Redis Deployment, NGINX Ingress with TLS, ConfigMap for environment, and Secrets (referenced by name). Include values.yaml with sensible defaults and a values.production.yaml example.",
      "acceptanceCriteria": [
        "Helm chart has Chart.yaml with correct apiVersion, name, version",
        "templates/ has Deployment + Service for auth, vault, org, audit, web services",
        "MySQL and Redis templates included (can be disabled for external services)",
        "Ingress template with TLS configuration",
        "`helm lint deploy/helm/vaultguard` passes with no errors",
        "`helm template` renders valid Kubernetes YAML"
      ],
      "passes": false
    },

    {
      "id": "ADV-001",
      "phase": 3,
      "title": "Secret scanning engine",
      "description": "Build the secret scanning service under services/scanner. It polls configured repositories (GitHub, GitLab) via their APIs for new commits/diffs and scans for credential patterns using regex (AWS keys, GCP service account keys, private keys, generic API tokens). On match: create a finding in a secret_findings table, notify the credential owner and org admins via email.",
      "acceptanceCriteria": [
        "services/scanner Go service with NATS JetStream consumer for scan jobs",
        "Regex patterns for: AWS Access Keys, GitHub Tokens, generic API tokens (starts with 'sk-', 'Bearer ', etc.)",
        "secret_findings table: id, org_id, repo_url, file_path, line_number, pattern_type, found_at",
        "GitHub repository scanning via GitHub API (token required in org settings)",
        "Email alert sent to credential owner and org admin on new finding",
        "Debounce: same secret on same file/line not re-reported within 24h"
      ],
      "passes": false
    },

    {
      "id": "ADV-002",
      "phase": 3,
      "title": "Emergency access workflow",
      "description": "Implement the emergency access feature. A user can designate one or more 'Emergency Contacts' (other org members). If the user is incapacitated, the emergency contact can request access. After a configurable wait period (24h–7 days, set by the user), if the account owner does not reject the request, the contact gains access to the vault. Implement: POST /api/v1/vault/emergency/designate, POST /api/v1/vault/emergency/request, GET /api/v1/vault/emergency/requests, POST /api/v1/vault/emergency/approve/{id} / reject/{id}.",
      "acceptanceCriteria": [
        "emergency_contacts table: requester_id, grantee_id, wait_period_hours",
        "emergency_access_requests table: id, requester_id, grantee_id, status, requested_at, approved_at",
        "POST /api/v1/vault/emergency/request sends notification email to account owner",
        "Owner can reject the request (resets the timer)",
        "After wait_period_hours elapses without rejection, request status auto-approves (scheduled job)",
        "On approval, account owner's encrypted vault is shared with requester"
      ],
      "passes": false
    },

    {
      "id": "ADV-003",
      "phase": 3,
      "title": "Passkey (FIDO2 discoverable credential) storage",
      "description": "Add passkey storage as a vault item type (type: 'passkey'). In the browser extension, implement passkey intercept: when a site requests a passkey via navigator.credentials.create() or .get(), the extension can serve stored passkeys from the vault or offer to save newly created passkeys. Store the passkey credential data (id, publicKey, algorithm) encrypted in the vault.",
      "acceptanceCriteria": [
        "Vault item type 'passkey' added to the enum",
        "Vault item for passkey stores: rpId, credentialId, publicKey, userHandle (all encrypted)",
        "Extension content script intercepts navigator.credentials.create() and offers to save the passkey",
        "Extension content script intercepts navigator.credentials.get() and serves matching passkeys",
        "Create and edit forms in web app support passkey item type display (read-only fields)"
      ],
      "passes": false
    },

    {
      "id": "ADV-004",
      "phase": 3,
      "title": "Automated compliance report generation",
      "description": "Implement compliance report generation at GET /api/v1/audit/reports/compliance?standard=soc2|iso27001|hipaa|gdpr. Each report is a JSON and PDF document summarizing: access control evidence, MFA adoption, audit log retention, encryption configuration, user management activities. Use a Go PDF library (e.g., jung-kurt/gofpdf or chromedp). Return as file download.",
      "acceptanceCriteria": [
        "GET /api/v1/audit/reports/compliance?standard=soc2 returns a downloadable PDF",
        "SOC 2 report includes: user access review, MFA enforcement status, audit log availability, encryption status",
        "GDPR report includes: data subjects, data retention policies, right-to-erasure capability",
        "Reports reference real data from the DB (user counts, MFA %, audit log date range)",
        "PDF is well-formatted with VaultGuard branding, table of contents, and page numbers",
        "Report generation cached for 1 hour (not regenerated on every request)"
      ],
      "passes": false
    },

    {
      "id": "ADV-005",
      "phase": 3,
      "title": "Credential rotation automation",
      "description": "Implement credential rotation webhooks. When a vault item's password is updated, VaultGuard can trigger a configured webhook with the new (encrypted) credential update event. Also build a rotation scheduler: allow users to set a rotation reminder on a vault item (rotate_every_days). A background job scans for overdue rotations and sends reminder notifications.",
      "acceptanceCriteria": [
        "vault_items table has rotate_every_days (nullable INT) and last_rotated_at (timestamp) columns",
        "PUT /api/v1/vault/items/{id} sets last_rotated_at when password field changes",
        "Background job runs daily and finds items where last_rotated_at + rotate_every_days < NOW()",
        "Reminder email sent to item owner for overdue rotations",
        "Webhook fired on vault_item.updated with event payload as per PDR Section 11.3",
        "Org webhook config stored in org_webhooks table (url, secret for HMAC-SHA256 signing)"
      ],
      "passes": false
    },

    {
      "id": "ADV-006",
      "phase": 3,
      "title": "SIEM integration (syslog/webhook)",
      "description": "Implement SIEM export from the audit service. Support: syslog (RFC 5424, CEF format) via UDP/TCP, and webhook delivery (POST to configured URL with CEF/LEEF payload). Admin configures SIEM targets at /admin/integrations/siem. Audit events forwarded in real-time via NATS JetStream consumer in the audit service.",
      "acceptanceCriteria": [
        "siem_targets table: id, org_id, type (syslog|webhook), host, port, format (CEF|LEEF|JSON), auth_token",
        "Audit service NATS consumer forwards events to all configured SIEM targets",
        "CEF format follows ArcSight CEF standard",
        "Syslog delivery retried up to 3 times on failure",
        "Webhook delivery uses HMAC-SHA256 signing header",
        "Admin UI at /admin/integrations/siem to add/test/remove SIEM targets"
      ],
      "passes": false
    }
  ]
}
